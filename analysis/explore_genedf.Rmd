---
title: "explore_genedf"
author: "AustinTHilliard"
date: '`r format(Sys.time(), "%d %B, %Y")`'
output: workflowr::wflow_html
---

## Setup
### Clean workspace, set options, load data
```{r start clean and load data}
rm(list=ls())
options(stringsAsFactors=FALSE)
genedf = readRDS("data/genedf.rds")
```
### Inspect and prepare data
In `genedf`, each row is a gene and each column is a different attribute.
Let's look at its dimensions and the first few rows.
```{r}
dim(genedf)
genedf[1:5, ]
```
Note that official _A. burtoni_ gene symbols are stored in the `geneSym` column.  
We'll see that right now the values in this column are stored as `factors`, but we want them to be `character` strings instead.
```{r}
# The fact that the output tells us there are 12368 "levels" is a tip-off that the values in this column are stored as factors.
genedf$geneSym[1:5]

# Fix the column so that the values are characters
genedf$geneSym = as.character(genedf$geneSym)
genedf$geneSym[1:5]
```
In fact, let's check whether other columns of `genedf` store values as factors, and if so, convert them to characters.
```{r}
# create a vector holding the class of each genedf column
genedfColClasses = sapply(genedf, class)
genedfColClasses
# create a vector that denotes which columns are factors
genedfFactorCols = genedfColClasses == "factor"
genedfFactorCols
# convert just these columns to characters using a simple for-loop
factorColNums = which(genedfFactorCols)
factorColNums
for (factorCol in factorColNums) {
  genedf[, factorCol] = as.character(genedf[, factorCol])
}
# always good practice to clean up variables used only during a loop
rm(factorColNums, factorCol)

# re-check the genedf column classes
sapply(genedf, class)
```

## Subsetting to specific genes
### One gene of interest
#### Set a specific gene name
This should be an official _A. burtoni_ gene symbol. Here we will use the androgen receptor gene _ar_.
```{r}
xgene = "ar"
```
#### Is the gene present at all in `genedf`, if so, where?
Create a vector of logical/boolean values testing whether values in `genedf$geneSym` are equal to the value in `xgene`. Entry _i_ corresponds to row _i_ in `genedf`.
```{r}
xgeneLogicalVec = genedf$geneSym == xgene
xgeneLogicalVec[1:5]
```
When a vector containing logical/boolean values is large we may want to test:  
1. Whether any entries are `TRUE`  
2. The exact locations of any entries that are `TRUE`
```{r}
# Note that the length of xgeneLogicalVec is the same as the number of rows in genedf
length(xgeneLogicalVec)
# Are any entries in xgeneLogicalVec TRUE?
any(xgeneLogicalVec)
# Which entries are TRUE?
xgeneRow = which(xgeneLogicalVec)
xgeneRow
```
#### Multiple equivalent ways to access the row in `genedf` containing information for the gene name stored in `xgene`.
```{r}
# Use the logical vector 
genedf[xgeneLogicalVec, ]
# Use the row number
genedf[xgeneRow, ]
# Use the subset() function
# It effectively creates a temporary vector like xgeneLogicalVec then subsets genedf
subset(genedf, geneSym == xgene)
```
Note that we could have just used `subset(genedf, geneSym == "ar")` from the beginning!

### Multiple genes of interest
#### Define a vector of gene names
Here we will get all the genes with "androgen" in their name/description (`desc` column)
```{r}
# see ?grep
androgenGeneRows = grep("androgen", genedf$desc, ignore.case=TRUE)
androgenGeneRows
```
Subset `genedf` to just the rows with these genes.
```{r}
genedf_androgenGenes = genedf[androgenGeneRows, ]
genedf_androgenGenes
```
Get rid of columns we don't care about here.
```{r}
toRemove = c("geneID", "location", "strand", "width", "biotype", "brOVzOV.tfbs")
toRemove = match(toRemove, names(genedf_androgenGenes))
toRemove
genedf_androgenGenes = genedf_androgenGenes[, -toRemove]
genedf_androgenGenes
```


```{r}

```








